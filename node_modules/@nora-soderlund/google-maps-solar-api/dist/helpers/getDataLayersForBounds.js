"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDataLayersForBounds = void 0;
const geolib_1 = require("geolib");
function getDataLayersForBounds(bounds, pixelSizeMeters, paddingMeters = 0) {
    const radiusMetersPerTile = Math.round(pixelSizeMeters * 999);
    const dataLayerView = (radiusMetersPerTile >= 175) ? ("IMAGERY_AND_ANNUAL_FLUX_LAYERS") : ("FULL_LAYERS");
    const northEast = (0, geolib_1.computeDestinationPoint)((0, geolib_1.computeDestinationPoint)(bounds.ne, paddingMeters, 0), paddingMeters, 90);
    const southWest = (0, geolib_1.computeDestinationPoint)((0, geolib_1.computeDestinationPoint)(bounds.sw, paddingMeters, 180), paddingMeters, 270);
    const horizontalDistance = (0, geolib_1.getDistance)(southWest, {
        latitude: southWest.latitude,
        longitude: northEast.longitude
    });
    const verticalDistance = (0, geolib_1.getDistance)(southWest, {
        latitude: northEast.latitude,
        longitude: southWest.longitude
    });
    const distancePerTile = radiusMetersPerTile * 2;
    const horizontalTiles = Math.ceil(horizontalDistance / distancePerTile);
    const verticalTiles = Math.ceil(verticalDistance / distancePerTile);
    const tiles = [];
    for (let row = 0; row < verticalTiles; row++) {
        const rowNorthEast = (0, geolib_1.computeDestinationPoint)(northEast, distancePerTile * row, 180);
        for (let column = 0; column < horizontalTiles; column++) {
            tiles.push((0, geolib_1.computeDestinationPoint)(rowNorthEast, distancePerTile * column, 270));
        }
    }
    return {
        radiusMetersPerTile,
        distancePerTile,
        dataLayerView,
        tiles,
        bounds: {
            ne: northEast,
            sw: southWest
        },
        horizontalTiles,
        verticalTiles
    };
}
exports.getDataLayersForBounds = getDataLayersForBounds;
;
//# sourceMappingURL=getDataLayersForBounds.js.map